/*
 * Code autogenerated by the Cemetery compiler
 *
 * Complains go to:
 *   Guido Mart√≠nez
 *   https://github.com/mtzguido/cemetery
 *   mtzguido@gmail.com
 */

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

struct __cmt_buf {
	size_t length;
	uint8_t data[];
};

#define __cmt_min(x, y) ({			\
	typeof(x) _min1 = (x);			\
	typeof(y) _min2 = (y);			\
	(void) (&_min1 == &_min2);		\
	_min1 < _min2 ? _min1 : _min2; })

typedef struct __cmt_buf *cmt_buf_t;

static inline __cmt_length(cmt_buf_t buf)
{
	return buf->length;
}

cmt_buf_t cmt_alloc(size_t length)
{
	cmt_buf_t ret;

	ret = malloc(sizeof *ret + length);
	ret->length = length;

	return ret;
}

cmt_buf_t __cmt_xor(cmt_buf_t l, cmt_buf_t r)
{
	cmt_buf_t ret;
	int i, length;

	length = __cmt_min(__cmt_length(l), __cmt_length(r));
	ret = cmt_alloc(length);

	for (i = 0; i < length; i++)
		ret->data[i] = l->data[i] ^ r->data[i];

	return ret;
}

/*
 * I'm not quite sure this is the way to go.
 *
 * Let's just declare it for now to silence
 * warnings and we'll see later if we really do
 * want hard length checking
 */
cmt_buf_t __cmt_trunc(cmt_buf_t buf)
{
	return buf;
}

/* Same comment as for __cmt_trunc */
#define __cmt_repeat __cmt_trunc

/* End of autogenerated code */
/* ------------------------- */

